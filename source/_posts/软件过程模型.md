---
title: 软件过程模型
pid: SE-Ch2-1
categories:
  - learn
tags: [学习,软件工程,SE,笔记]
date: 2016-10-23 18:22:16
---
<center>本文是《软件工程》课程第二章“软件过程模型”的总结与整理。</center>

<!-- more -->

---

# 软件过程

软件过程定义了以下内容:

* 人员与分工
* 所执行的活动
* 活动的细节和步骤

软件过程通过以下方式来组织和管理软件生命周期:

* 定义软件生产过程中的活动
* 定义这些活动的顺序及其关系

软件过程的目的:

* 标准化(可模仿)\可预见性(降低风险)\提高开发效率\得到高质量产品
* 提升制定时间和预算计划的能力


Code-and-Fix 不适用于开发一个复杂的软件，软件开发需要过程支持。

# 典型的软件过程模型

## 瀑布模型(Waterfall)

![选区_032.png](https://ooo.0o0.ooo/2016/12/21/585a5a1237b36.png)

也叫"鲑鱼模型": 向前一阶段回溯，很难。


优点:(追求效率)

1. 简单移懂、易用快速
2. 为项目提供了按阶段划分的检查点，项目管理比较容易
3. 每个阶段必须提供文档，而且要求每个阶段的所有产品都必须进行正式、严格的技术审查。

缺点:(过于理想化)

1. 在开发早期，用户难以清楚地确定所有需求,需求的错误很难在开发后期纠正,因此难以快速响应用户需求变更;
2. 开发人员与用户之间缺乏有效的沟通,开发人员的工作几乎完全依赖规格说明文档,容易导致不能满足客户需求。
3. 客户必须在项目接近尾声的时候才能得到可执行的程序,对系统中存在的重大缺陷,如果在评审之前没有被发现,将可能会造成重大损失。


适用场合:

* 软件项目较小，各模块接口定义十分清晰
* 需求在开始之前已经被全面了解，产品定义十分稳定
* 需求在开发中不太可能发生重大改变
* 使用的技术十分成熟，团队成员都很熟悉这些技术
* 负责各个步骤的子团队分属不同的机构或不同的地理位置，因此不可能做到频繁的交流
* 外部环境的不可控因素很少



## 增量过程模型(Incremental process model)


无须等到所有需求都出来才进行开发,只要某个需求的核心部分出来,即可进行开发;
另外,可能迫切需要为用户迅速提供一套功能有限的软件产品,然后在后续版本中再细化和扩展功能。

### 增量模型

![选区_033.png](https://ooo.0o0.ooo/2016/12/21/585a5f476cab5.png)

软件被看作是一系列的增量来设计、实现、集成和测试，每一个增量是由多种相互作用的模块所形成的提供功能的代码片段构成。

本质:以迭代的方式运用瀑布模型

* 第一个增量往往是核心产品:满足了基本的需求,但是缺少附加的特性;
* 客户使用上一个增量的提交物并进行自己评价,制定下一个增量计划,说明需要增加的特性和功能;
* 重复上述过程,直到最终产品产生为止。


优点:

* 在时间要求较高的情况下交付产品:在各个阶段并不交付一个可运行的完整产品,而是交付满足客户需求的一个子集的可运行产品,对客户起到“镇静剂”的作用;
* 人员分配灵活:如果找不到足够的开发人员,可采用增量模型:早期的增量由少量人员实现,如果客户反响较好,则在下一个增量中投入更多的人力;
* 逐步增加产品功能可以使用户有较充裕的时间来学习和适应新产品,避免全新软件可能带来的冲击;
* 因为具有较高优先权的模块被首先交付,而后面的增量也不断被集成进来,这使得最重要的功能肯定接受了最多的测试,从而使得项目总体性失败的风险比较低。

困难:

* 每个附加的增量并入现有的软件时,必须不破坏原来已构造好的东西。
* 同时,加入新增量时应简单、方便 ——该类软件的体系结构应当是开放的;
* 仍然无法处理需求发生变更的情况
* 管理人员须有足够的技术能力来协调好各增量之间的关系。


### RAD模型

![选区_034.png](https://ooo.0o0.ooo/2016/12/21/585a60d0565ee.png)

快速应用开发RAD(Rapid Application Development)

* 侧重于短开发周期(一般为60~90天)的增量过程模型，是瀑布模型的高速变体,通过**基于构件的构建方法**实现快速开发;

* 多个团队并行开发，但启动时间有先有后，先启动团队的提交物将作为后启动团队的输入。

缺点:

* 需要大量的人力资源来创建多个相对独立的RAD团队
* 如果没有在短时间内为急速完成整个系统做好准备,RAD项目将会失败;
* 如果系统不能被合理的模块化,RAD将会带来很多问题;
* 技术风险很高的情况下(采用很多新技术、软件需与其他已有软件建立集成等等),不宜采用RAD。


## 演化过程模型(Evolutionary model)

在开发过程中,需求经常发生变化。严格的交付时间使得开发团队不可能圆满完成软件产品，但是必须交
付功能有限的版本以应对竞争或压力。很好的理解和核心产品与系统需求,但对其他扩展的细节问题却没有
定义。在上述情况下,需要一种专门应对不断演变的软件过程模型,即“演化过程模型”。

本质:循环、反复、不断调整当前系统以适应需求变化;

包括两种形态:

* 快速原型法
* 螺旋模型


演化过程模型的目的:  需求的变更频繁,要求在非常短的期限内实现,以充分满足客户/用户要求、
及时投入市场.

存在的问题:

* 由于构建产品所需的周期数据不确定,给项目管理带来困难;
* 演化速度太快,项目陷入混乱;演化速度太慢,影响生产率;
* 为追求软件的高质量而牺牲了开发速度、灵活性和可扩展性;



### 快速原型法

![选区_035.png](https://ooo.0o0.ooo/2016/12/21/585a6270ea7ce.png)

步骤:

1. 双方通过沟通,明确已知的需求,并大致勾画出以后再进一步定义的东西。
2. 迅速策划一个原型开发迭代并进行建模,主要集中于那些最终用户所能够看到的方面,如人机接口布局或者输出显示格式等;
3. 快速设计产生原型,对原型进行部署,由客户和用户进行评价;
4. 根据反馈,进一步细化需求并调整原型;
5. 原型系统不断调整以逼近用户需求。


原型的类型

1. 抛弃式原型(Throwaway prototyping)
2. 演化式原型(Evolutionary prototyping)

优点:

提高和改善客户/用户的参与程度,最大程度的响应用户需求的变化

缺点:

* 为了尽快完成原型,开发者没有考虑整体软件的质量和长期的可维护性,系统结构通常较差;
* 可能混淆原型系统与最终系统,原型系统在完全满足用户需求之后可能会被直接交付给客户使用;
* 额外的开发费用。

### 螺旋式过程模型

![选区_036.png](https://ooo.0o0.ooo/2016/12/21/585a63bdad6b8.png)

螺旋模型沿着螺线旋转，在四个象限内表达四个方面的活动


出发点:开发过程中及时识别和分析风险,并采取适当措施以消除或减少风险来的危害。


优点:

结合了原型的迭代性质与瀑布模型的系统性和可控性,是一种风险驱动型的过程模型:
* 采用循环的方式逐步加深系统定义和实现的深度,同时更好的理解、应对和降低风险;
* 确定一系列里程碑,确保各方都得到可行的系统解决方案;
* 始终保持可操作性,直到软件生命周期的结束;
* 由风险驱动,支持现有软件的复用。

缺点:

* 适用于大规模软件项目,特别是内部项目,周期长、成本高;
* 软件开发人员应该擅长寻找可能的风险,准确的分析风险,否则将会带来更大的风险。

## 形式化过程模型(Formal model)

![选区_037.png](https://ooo.0o0.ooo/2016/12/21/585a6552d1ba2.png)

优点:

应用数学分析方法,歧义性、不完整性、不一致性等问题更容易被发现和改正,目的是“提供无缺陷的软件”。

缺点:

* 形式化数学方法难以理解,可视性太差,对开发人员技能要求较高;
* 构造形式化模型是一件非常耗时的工作,成本也很高;
* 软件系统中的某些方面难以用形式化模型表达出来(如用户界面);


应对场合:

对可靠性和安全性要求较高的一些关键系统,在真正被投入使用之前,需要
严格保证100%的正确。传统的方法靠人去验证,难以奏效。


## 面向复用的软件过程

主要思想: 复用

针对一个新的软件系统,不是完全从一无所有开始入手,而是通过使用已有的软件单元(称为“软构件”)来构造系统。




