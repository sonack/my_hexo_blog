---
title: 人工智能搜索算法
pid: ai-search
categories:
  - algorithm
tags: [learn,AI,summary]
date: 2016-12-30 16:54:55
---
搜索策略是人工智能领域常用的方法之一，本文主要介绍几种常见的搜索策略及其实现，主要内容包括搜索的概述、状态空间搜索(盲目式、启发式)、与/或树搜索和博弈树的启发式搜索等算法。

<!-- more -->

---

## 搜索概述

### 基本概念及分类

**概念: 依靠经验，利用已有知识，根据问题的实际情况，不断寻找可利用知识，从而构造一条代价最小的推理路线，使问题得以解决的过程称为搜索。**

适用于不良结构或者非结构化问题，难以获得求解所需的全部信息，更没有现成的算法可供求解使用。

搜索的类型按照是否使用启发式信息可以分为

* __盲目搜索__: 按预定的控制策略进行搜索，在搜索过程中获得的中间信息并不改变控制策略。
* __启发式搜索__: 在搜索中加入了与问题有关的启发性信息，用于指导搜索朝着最有希望的方向前进，加速问题的求解过程并找到最优解。


按问题的表示方式分类，可分为

* __状态空间搜索__: 用状态空间法来求解问题
* __与/或树搜索__: 用问题归约法来求解问题

### 问题概述

问题可以形式化地定义为三个组成部分:

1. 初始状态(Initial State) (s0);
2. 后继函数:
    操作函数(Actions): Actions(s)->{a1,a2,a3,...}
    路径耗散函数(PathCost):
    PathCost(s0[a1]->s1[ai-1] ... -> si) -> n
3. 目标测试函数(GoalTest):
    GoalTest(s0[a1]) -> T/F

问题的解： 从初始状态到目标状态的操作的序列。 (s0->s1 ... -> sn)

#### 状态空间法

__状态(State)__: 表示问题求解过程中每一步问题状况的数据结构，可形式地表示为:

![](http://latex.codecogs.com/png.latex?S_k%20%3D%20%5Cleft%5C%7B%20S_k_0%2C%20S_k_1%2C%20...%20%5Cright%5C%7D)

当对每一个分量都给予确定值时，就得到了一个具体的状态。

__操作(Operator)__: 也叫算符，它是把问题从一种状态变换为另一种状态的手段，操作可以是一个机械步骤、一个运算、一条规则或者一个过程。操作可理解为状态集合上的一个函数，它描述了状态之间的关系。

__状态空间(State Space)__: 用来描述一个问题的全部状态以及这些状态之间的相互关系。常用一个三元组表示为:

![](http://latex.codecogs.com/png.latex?%5Cleft%5C%7B%20S%2C%20F%2C%20G%20%5Cright%5C%7D)

其中，S是问题的所有初始状态的集合，F为操作的集合，G是目标状态的集合。

状态空间也可以用一个赋值的有向图来表示，该有向图称为_状态空间图_，其中节点表示问题的状态，有向边表示操作。

状态空间法求解问题的基本过程为

1. 为问题选择适当的“状态”和“操作”的形式化描述方法
2. 从某个初始状态出发，每次使用一个操作，递增地建立起操作序列，直到达到目标状态为止
3. 由初始状态到目标状态所使用的算符(操作)序列就是该问题的一个解

#### 问题归约法

__问题的与/或树表示__

当一个问题比较复杂时，可以通过分解或变换，将其转化为一系列较简单的子问题，然后通过对这些子问题的求解来实现对原问题的求解。

__分解__

如果一个问题P可以归约为一组子问题P1,P2,...,Pn，并且只有当所有子问题Pi都有解时原问题P才有解，任何一个子问题Pi无解都会导致原问题P无解，则称此种归约为问题的分解。

即分解所得到的子问题的"与"和原问题P等价。

把一个问题分解为若干个子问题时，可以用一个“与树”来表示这种分解。

![Markdown](http://i1.piimg.com/1949/5219aa28b4c329e0.png)


__等价变换__

如果一个问题P可以归约为一组子问题P1,P2,..,Pn，并且子问题Pi中只要有一个有解，则原问题P就有解。只有当所有子问题Pi都无解时原问题P才无解，称此种归约为问题的等价变换，简称变换。

即变换所得到的子问题的“或”和原问题P等价。

把一个问题等价变换为若干个与之等价的新问题时，可用一个“或树”来表示这种变换。

![Markdown](http://i1.piimg.com/1949/536bddcd921f7eab.png)


__与/或树__

如果一个问题既需要分解，又需要变换才能得到其本原问题，则其求解过程可用一个"与/或树"表示。

![](http://p1.bpimg.com/567571/1b83d37b609d15e7.png)

端节点: 没有子节点的节点
终止节点: 本原问题所对应的节点

终止节点一定是端节点，但端节点却不一定是终止节点。


*可解节点与不可解节点*
在与/或树中，满足以下三个条件之一的节点为可解节点:
1. 任何终止节点都是可解节点。
2. 对"或"节点，当其子节点中至少有一个为可解节点时，则该或节点也是可解节点。
3. 对"与"节点，当其所有子节点全部为可解节点时，则该与节点才是可解节点。

不可解节点的定义类似：

1. 不为终止节点的端节点是不可解节点。
2. 对"或"节点，若其全部子节点都为不可解节点，则该或节点是不可解节点。
3. 对"与"节点，只要其子节点中有一个为不可解节点，则该与节点是不可解节点。


## 状态空间盲目搜索

基本思想:
先把问题的初始状态作为当前扩展节点对其进行扩展，生成一组子节点，然后检查问题的目标状态是否出现在这些子节点之中。如果出现，则搜索成功，找到问题的解。若没出现，则再按某种搜索策略从已生成的子节点中选择一个节点作为当前扩展节点。
重复上述过程，直到目标状态出现在子节点中或者没有可供操作的节点为止。
所谓对一个节点进行__扩展__操作，是指对该节点用某个可用__操作__进行作用，生成该节点的一组子节点。


__算法的数据结构和符号约定__

Open表:
用于存放刚刚生成的节点，未扩展的节点，Open表称为未扩展的节点。

Closed表:
用于存放已经扩展的或将要扩展的节点，Closed称为已扩展的节点表。

S0:
用来表示问题的初始状态。

Sg:
用来表示问题的目标状态。


### 一般图搜索过程

1. 把S0放入Open表，并建立目前仅包含S0的图G，建立一个Closed表，置为空。
2. 检查Open表是否为空表，若为空，则问题无解，失败退出。
3. 把Open表的第一个节点取出放入Closed表，并记该节点为n。
4. 考察节点n是否为目标节点，若是则得到问题的解，成功退出。
5. 扩展节点n，生成一组子节点。把这些子节点中不是父节点的那部分子节点计入集合M，并把这些子节点作为节点n的子节点加入图G中。
6. 针对M中子节点的不同情况，分别处理如下:
    * 对那些没有在G中出现过的M成员设置一个指向其父节点(即节点n)的指针，并把它放入Open表。
    * 对那些原来已经在G中出现过，但没有被扩展的M成员，确定是否需要修改它指向父节点的指针。
    * 对那些原来已经在G中出现过，并已经被扩展过的M成员，确定是否需要修改其后继节点指向父节点的指针。
7. 按某种策略对Open表中的节点进行排序
8. 转第2步


